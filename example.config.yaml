rules:
  # Constructor pattern
  - name: "constructor_pattern"
    category: "code_pattern"
    description: "Standard constructor pattern for Go types"
    language: "go"
    examples:
      - description: "Basic constructor"
        code: |
          func NewUser(name string, age int) *User {
              return &User{
                  name: name,
                  age: age,
              }
          }
      - description: "Constructor with validation"
        code: |
          func NewConfig(serverAddr string, timeout time.Duration) (*Config, error) {
              if serverAddr == "" {
                  return nil, errors.New("server address is required")
              }
              if timeout <= 0 {
                  return nil, errors.New("timeout must be positive")
              }
              return &Config{
                  serverAddr: serverAddr,
                  timeout:    timeout,
              }, nil
          }

  # Interface naming pattern
  - name: "interface_naming"
    category: "naming"
    description: "Go interface naming conventions"
    language: "go"
    examples:
      - description: "Single method interface"
        code: |
          type Reader interface {
              Read(p []byte) (n int, err error)
          }
      - description: "Multi-method interface"
        code: |
          type UserService interface {
              Create(ctx context.Context, user *User) error
              Get(ctx context.Context, id string) (*User, error)
              Update(ctx context.Context, user *User) error
              Delete(ctx context.Context, id string) error
          }

  # Package organization
  - name: "package_organization"
    category: "organization"
    description: "Go package organization patterns"
    language: "go"
    examples:
      - description: "Domain-driven package structure"
        code: |
          project/
          ├── cmd/                    # Main applications
          │   └── app/               # Application-specific code
          │       └── main.go        # Application entry point
          ├── pkg/                   # Project packages
          │   ├── api/              # API handlers
          │   ├── core/             # Core business logic
          │   ├── service/          # Business operations
          │   ├── repo/             # Data access
          │   └── types/            # Shared types
      - description: "Package naming"
        code: |
          package user       // Good: single word
          package imageutil  // Good: no underscore for utility
          package api       // Good: short and clear
          package database  // Good: describes functionality

  # Error handling
  - name: "error_handling"
    category: "errors"
    description: "Go error handling patterns"
    language: "go"
    examples:
      - description: "Custom error types"
        code: |
          type NotFoundError struct {
              Resource string
              ID      string
          }

          func (e *NotFoundError) Error() string {
              return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
          }

          // Usage
          if err := repo.Get(id); err != nil {
              return &NotFoundError{
                  Resource: "user",
                  ID:      id,
              }
          }
      - description: "Error wrapping"
        code: |
          if err := validate(data); err != nil {
              return fmt.Errorf("validate data: %w", err)
          }

  # Concurrency patterns
  - name: "concurrency_patterns"
    category: "concurrency"
    description: "Go concurrency patterns"
    language: "go"
    examples:
      - description: "Worker pool"
        code: |
          func worker(id int, jobs <-chan Job, results chan<- Result) {
              for job := range jobs {
                  results <- process(job)
              }
          }

          func main() {
              jobs := make(chan Job, 100)
              results := make(chan Result, 100)

              // Start workers
              for w := 1; w <= 3; w++ {
                  go worker(w, jobs, results)
              }

              // Send jobs
              for _, job := range jobs {
                  jobs <- job
              }
              close(jobs)

              // Collect results
              for range jobs {
                  <-results
              }
          }
      - description: "Context cancellation"
        code: |
          func process(ctx context.Context, data []byte) error {
              select {
              case <-ctx.Done():
                  return ctx.Err()
              default:
                  return processData(data)
              }
          }

  # Testing patterns
  - name: "testing_patterns"
    category: "testing"
    description: "Go testing patterns"
    language: "go"
    examples:
      - description: "Table-driven tests"
        code: |
          func TestValidate(t *testing.T) {
              tests := []struct {
                  name    string
                  input   string
                  wantErr bool
              }{
                  {
                      name:    "valid input",
                      input:   "test",
                      wantErr: false,
                  },
                  {
                      name:    "empty input",
                      input:   "",
                      wantErr: true,
                  },
              }

              for _, tt := range tests {
                  t.Run(tt.name, func(t *testing.T) {
                      err := Validate(tt.input)
                      if (err != nil) != tt.wantErr {
                          t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
                      }
                  })
              }
          }
      - description: "Subtests with setup/teardown"
        code: |
          func TestService(t *testing.T) {
              // Setup
              s := NewService()
              defer s.Close() // Teardown

              t.Run("Create", func(t *testing.T) {
                  // Test create operation
              })

              t.Run("Update", func(t *testing.T) {
                  // Test update operation
              })
          }

  # Interface design
  - name: "interface_design"
    category: "interfaces"
    description: "Go interface design patterns"
    language: "go"
    examples:
      - description: "Small interfaces"
        code: |
          type Reader interface {
              Read(p []byte) (n int, err error)
          }

          type Writer interface {
              Write(p []byte) (n int, err error)
          }

          // Compose interfaces
          type ReadWriter interface {
              Reader
              Writer
          }
      - description: "Interface as contract"
        code: |
          type Storage interface {
              Save(ctx context.Context, key string, value []byte) error
              Load(ctx context.Context, key string) ([]byte, error)
              Delete(ctx context.Context, key string) error
          }

          // Implementation
          type RedisStorage struct {
              client *redis.Client
          }

          func (s *RedisStorage) Save(ctx context.Context, key string, value []byte) error {
              return s.client.Set(ctx, key, value, 0).Err()
          }
