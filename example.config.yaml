rules:
  # Constructor pattern
  - name: "constructor_pattern"
    category: "code_pattern"
    description: "Standard constructor pattern for Go types"
    language: "go"
    examples:
      - description: "Basic constructor"
        code: |
          func NewUser(name string, age int) *User {
              return &User{
                  name: name,
                  age: age,
              }
          }
      - description: "Constructor with validation"
        code: |
          func NewConfig(serverAddr string, timeout time.Duration) (*Config, error) {
              if serverAddr == "" {
                  return nil, errors.New("server address is required")
              }
              if timeout <= 0 {
                  return nil, errors.New("timeout must be positive")
              }
              return &Config{
                  serverAddr: serverAddr,
                  timeout:    timeout,
              }, nil
          }

  # Basic test pattern
  - name: "basic_test_pattern"
    category: "testing"
    description: "Standard test pattern using testify assertions"
    language: "go"
    examples:
      - description: "Basic test with testify"
        code: |
          func TestCreateUser(t *testing.T) {
              // Arrange
              assert := assert.New(t)
              require := require.New(t)
              
              // Act
              user, err := CreateUser("John", 25)
              
              // Assert
              require.NoError(err)
              assert.Equal("John", user.Name)
              assert.Equal(25, user.Age)
          }
      - description: "Test with setup and cleanup"
        code: |
          func TestProcessData(t *testing.T) {
              // Arrange
              assert := assert.New(t)
              require := require.New(t)
              
              // Setup test data
              data := setupTestData(t)
              defer cleanupTestData(t)
              
              // Act
              result, err := ProcessData(data)
              
              // Assert
              require.NoError(err)
              assert.NotNil(result)
              assert.Equal(expected, result.Value)
          }

  # Table-driven test pattern
  - name: "table_test_pattern"
    category: "testing"
    description: "Table-driven test pattern for multiple test cases"
    language: "go"
    examples:
      - description: "Table test for validation function"
        code: |
          func TestValidateUser(t *testing.T) {
              tests := []struct {
                  name    string
                  user    User
                  wantErr error
              }{
                  {
                      name: "valid user",
                      user: User{Name: "John", Age: 25},
                      wantErr: nil,
                  },
                  {
                      name: "invalid age",
                      user: User{Name: "John", Age: -1},
                      wantErr: ErrInvalidAge,
                  },
              }
              
              for _, tt := range tests {
                  t.Run(tt.name, func(t *testing.T) {
                      err := ValidateUser(tt.user)
                      if tt.wantErr != nil {
                          assert.ErrorIs(t, err, tt.wantErr)
                          return
                      }
                      assert.NoError(t, err)
                  })
              }
          }

  # Error handling pattern
  - name: "error_handling"
    category: "error"
    description: "Standard error handling patterns"
    language: "go"
    examples:
      - description: "Error wrapping"
        code: |
          func ProcessUser(user *User) error {
              if user == nil {
                  return ErrInvalidInput
              }
              
              if err := validate(user); err != nil {
                  return fmt.Errorf("validate user: %w", err)
              }
              
              return nil
          }
      - description: "Custom error types"
        code: |
          type NotFoundError struct {
              ID string
          }
          
          func (e *NotFoundError) Error() string {
              return fmt.Sprintf("user not found: %s", e.ID)
          }

  # Function documentation pattern
  - name: "func_doc_standard"
    category: "documentation"
    description: "Standard documentation format for Go functions"
    language: "go"
    examples:
      - description: "Simple function documentation"
        code: |
          // Sum adds two integers and returns their sum.
          func Sum(a, b int) int
      - description: "Complex function documentation"
        code: |
          // ProcessData validates and transforms the input data according to the specified options.
          // It applies each transformation sequentially and stops on the first error encountered.
          // Data is the raw input to be processed
          // Options control the transformation behavior
          // Returns processed data in the requested format
          // Returns error if validation fails or any transformation step errors
          func ProcessData(data []byte, opts *Options) ([]byte, error)

  # Package documentation pattern
  - name: "package_doc_standard"
    category: "documentation"
    description: "Standard documentation format for Go packages"
    language: "go"
    examples:
      - description: "Package documentation"
        code: |
          // Package calculator provides basic arithmetic operations
          // and advanced mathematical calculations.
          //
          // It implements common mathematical functions and utilities
          // while ensuring thread-safety and proper error handling.
          package calculator

  # Interface documentation pattern
  - name: "interface_doc_standard"
    category: "documentation"
    description: "Standard documentation format for Go interfaces"
    language: "go"
    examples:
      - description: "Interface documentation"
        code: |
          // Reader is the interface that wraps the basic Read method.
          //
          // Read reads up to len(p) bytes into p. It returns the number of bytes
          // read (0 <= n <= len(p)) and any error encountered.
          type Reader interface {
              Read(p []byte) (n int, err error)
          }
      - description: "Complex interface documentation"
        code: |
          // UserRepository defines the interface for user data access operations.
          //
          // It provides methods for CRUD operations on user entities and ensures
          // proper transaction handling and data consistency.
          type UserRepository interface {
              Create(ctx context.Context, user *User) error
              Get(ctx context.Context, id string) (*User, error)
              Update(ctx context.Context, user *User) error
              Delete(ctx context.Context, id string) error
          }
