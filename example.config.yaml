rules:
  # Constructor pattern
  - name: "constructor_pattern"
    category: "code"
    description: "Standard constructor pattern for Go types"
    examples:
      - description: "Basic constructor"
        code: |
          func NewUser(name string, age int) *User {
              return &User{
                  name: name,
                  age: age,
              }
          }
      - description: "Constructor with validation"
        code: |
          func NewConfig(serverAddr string, timeout time.Duration) (*Config, error) {
              if serverAddr == "" {
                  return nil, errors.New("server address is required")
              }
              if timeout <= 0 {
                  return nil, errors.New("timeout must be positive")
              }
              return &Config{
                  serverAddr: serverAddr,
                  timeout:    timeout,
              }, nil
          }

  # Interface naming pattern
  - name: "interface_naming"
    category: "code"
    description: "Go interface naming conventions"
    examples:
      - description: "Single method interface"
        code: |
          type Reader interface {
              Read(p []byte) (n int, err error)
          }
      - description: "Multi-method interface"
        code: |
          type UserService interface {
              Create(ctx context.Context, user *User) error
              Get(ctx context.Context, id string) (*User, error)
              Update(ctx context.Context, user *User) error
              Delete(ctx context.Context, id string) error
          }

  # Package organization
  - name: "package_organization"
    category: "code"
    description: "Go package organization patterns"
    examples:
      - description: "Domain-driven package structure"
        code: |
          project/
          ├── cmd/                    # Main applications
          │   └── app/               # Application-specific code
          │       └── main.go        # Application entry point
          ├── pkg/                   # Project packages
          │   ├── api/              # API handlers
          │   ├── core/             # Core business logic
          │   ├── service/          # Business operations
          │   ├── repo/             # Data access
          │   └── types/            # Shared types
      - description: "Package naming"
        code: |
          package user       // Good: single word
          package imageutil  // Good: no underscore for utility
          package api       // Good: short and clear
          package database  // Good: describes functionality

  # Error handling
  - name: "error_handling"
    category: "code"
    description: "Go error handling patterns"
    examples:
      - description: "Custom error types"
        code: |
          type NotFoundError struct {
              Resource string
              ID      string
          }

          func (e *NotFoundError) Error() string {
              return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
          }

          // Usage
          if err := repo.Get(id); err != nil {
              return &NotFoundError{
                  Resource: "user",
                  ID:      id,
              }
          }
      - description: "Error wrapping"
        code: |
          if err := validate(data); err != nil {
              return fmt.Errorf("validate data: %w", err)
          }

  # Function documentation
  - name: "func_documentation"
    category: "documentation"
    description: "Standard documentation format for Go functions"
    examples:
      - description: "Simple function documentation"
        code: |
          // Sum adds two integers and returns their sum.
          func Sum(a, b int) int
      - description: "Complex function documentation"
        code: |
          // ProcessData validates and transforms the input data according to the specified options.
          // It applies each transformation sequentially and stops on the first error encountered.
          // Data is the raw input to be processed
          // Options control the transformation behavior
          // Returns processed data in the requested format
          // Returns error if validation fails or any transformation step errors
          func ProcessData(data []byte, opts *Options) ([]byte, error)

  # Package documentation
  - name: "package_documentation"
    category: "documentation"
    description: "Standard documentation format for Go packages"
    examples:
      - description: "Package documentation"
        code: |
          // Package calculator provides basic arithmetic operations
          // and advanced mathematical calculations.
          //
          // It implements common mathematical functions and utilities
          // while ensuring thread-safety and proper error handling.
          package calculator

  # Interface documentation
  - name: "interface_documentation"
    category: "documentation"
    description: "Standard documentation format for Go interfaces"
    examples:
      - description: "Interface documentation"
        code: |
          // Reader is the interface that wraps the basic Read method.
          //
          // Read reads up to len(p) bytes into p. It returns the number of bytes
          // read (0 <= n <= len(p)) and any error encountered.
          type Reader interface {
              Read(p []byte) (n int, err error)
          }

  # Table-driven tests
  - name: "table_tests"
    category: "testing"
    description: "Table-driven test patterns for Go"
    examples:
      - description: "Basic table test"
        code: |
          func TestValidate(t *testing.T) {
              tests := []struct {
                  name    string
                  input   string
                  wantErr bool
              }{
                  {
                      name:    "valid input",
                      input:   "test",
                      wantErr: false,
                  },
                  {
                      name:    "empty input",
                      input:   "",
                      wantErr: true,
                  },
              }

              for _, tt := range tests {
                  t.Run(tt.name, func(t *testing.T) {
                      err := Validate(tt.input)
                      if (err != nil) != tt.wantErr {
                          t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
                      }
                  })
              }
          }

  # Test setup/teardown
  - name: "test_setup"
    category: "testing"
    description: "Test setup and teardown patterns"
    examples:
      - description: "Setup and teardown"
        code: |
          func TestService(t *testing.T) {
              // Setup
              s := NewService()
              defer s.Close() // Teardown

              t.Run("Create", func(t *testing.T) {
                  // Test create operation
              })

              t.Run("Update", func(t *testing.T) {
                  // Test update operation
              })
          }

  # Application template
  - name: "Excecutable files"
    category: "template"
    description: "All main go files should be logcatead in ./cmd/example-app/main.go directory"
    examples:
      - description: "Main file should not contain any logic, only responsible for starting the application"
        code: |
          package main

          import (
            "context"
            "log/slog"
            "os"
            "os/signal"
            "syscall"

            "github.com/user/example/pkg/cmd"
          )

          // version is the version of the application. It should be set at build time.
          var version = "dev"

          func main() {
            ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

            rootCmd := cmd.InitCommands(version)

            if err := rootCmd.ExecuteContext(ctx); err != nil {
              slog.Error("failed to execute command", slog.Any("error", err))
              os.Exit(1)
            }
          }
  - name: "Command Line Interface"
    category: "template"
    description: "All command line interfaces loggic and also wiring logic should be located in ./pkg/cmd directory"
    examples:
      - description: "CLI commands initialization, we should use cobra framework for designing cli interface of the application. File should be located in ./pkg/cmd/init.go"
        code: |
          package cmd

          import (
            "fmt"
            "log/slog"

            "github.com/spf13/cobra"
          )

          type args struct {
            version              string
            LogLevel             string
            ConfigPath           string
            TextFormat           bool
          }

          // InitCommands initializes and returns the root command for the application.
          func InitCommands(version string) (*cobra.Command, error) {
            args := &args{
              build:   build,
              version: version,
            }

            cmd := &cobra.Command{
              Use:   "example-app",
              Short: "Example application",
              Long:  "Example application for demonstrating best practices",
            }

            cmd.AddCommand(ServerCommand(args))

            cmd.PersistentFlags().StringVar(&args.ConfigPath, "config", "", "config file path")
            cmd.PersistentFlags().StringVar(&args.LogLevel, "loglevel", "info", "log level (debug, info, warn, error)")
            cmd.PersistentFlags().BoolVar(&args.TextFormat, "logtext", false, "log in text format, otherwise JSON")

            return cmd, nil
          }

          // ServerCommand creates a new cobra.Command to start example-app server.
          func ServerCommand(arg *args) *cobra.Command {
            return &cobra.Command{
              Use:   "server",
              Short: "Start Example server",
              Long:  "Start Example server",
              RunE: func(cmd *cobra.Command, _ []string) error {
                if err := initLogger(arg); err != nil {
                  return err
                }

                slog.Info("Starting Example server", slog.String("version", arg.version), slog.String("build", arg.build))

                cfg, err := initConfig(arg)
                if err != nil {
                  return err
                }

                return runServer(cmd.Context(), cfg)
              },
            }
          }
      - description: "Configuration initialization, we should use viper for configuration management. File should be located in ./pkg/cmd/config.go"
        code: |
          package cmd

          import (
            "context"
            "fmt"
            "log/slog"

            "github.com/user/example/pkg/api"
            "github.com/user/example/pkg/repo"
            "github.com/spf13/viper"
          )

          type Config struct {
            Server    api.Config    `mapstructure:"api"`
            Database  repo.Config   `mapstructure:"database"`
          }

          // initConfig initializes the configuration by reading from the specified config file.
          func initConfig(arg *args) (*Config, error) {
            v := viper.New()

            v.SetConfigFile(arg.ConfigPath)

            if err := v.ReadInConfig(); err != nil {
              return nil, fmt.Errorf("failed to read config: %w", err)
            ]

            var cfg Config

            v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
            v.AutomaticEnv()

            if err := v.Unmarshal(&cfg); err != nil {
              return nil, fmt.Errorf("failed to unmarshal config: %w", err)
            }

            slog.Debug("Config loaded", slog.Any("config", cfg))

            return &cfg, nil
          }
      - description: "Logger initialization, we should use log/slog for logging. File should be located in ./pkg/cmd/logger.go"
        code: |
          package cmd

          import (
            "log/slog"
            "os"
          )

          // initLogger initializes the default logger for the application using slog.
          func initLogger(arg *args) error {
            var logLever slog.Level
            if err := logLever.UnmarshalText([]byte(arg.LogLevel)); err != nil {
              return err
            }

            options := &slog.HandlerOptions{
              Level: logLever,
            }

            var logHandler slog.Handler
            if arg.TextFormat {
              logHandler = slog.NewTextHandler(os.Stdout, options)
            } else {
              logHandler = slog.NewJSONHandler(os.Stdout, options)
            }

            logger := slog.New(logHandler).With(
              slog.String("ver", arg.version),
              slog.String("app", "example-app"),
            )

            slog.SetDefault(logger)

            return nil
          }
