# Example of a code pattern rule
- name: "constructor_pattern"
  category: "code_pattern"
  type: "template"
  description: "Standard constructor pattern for Go types"
  pattern:
    template: |
      func New{{.TypeName}}({{.Params}}) *{{.TypeName}} {
          return &{{.TypeName}}{
              {{.Fields}}
          }
      }
    format: "go"
  applies_to: ["struct"]
  priority: 1
  required: true
  examples:
    - description: "Basic constructor"
      code: |
        func NewUser(name string, age int) *User {
            return &User{
                name: name,
                age: age,
            }
        }

# Basic test pattern with testify
- name: "basic_test_pattern"
  category: "testing"
  type: "template"
  description: "Standard test pattern using testify assertions"
  pattern:
    template: |
      func Test{{.Name}}(t *testing.T) {
          // Arrange
          assert := assert.New(t)
          require := require.New(t)
          
          // Act
          {{.TestLogic}}
          
          // Assert
          require.NoError(err)
          assert.Equal(expected, result)
      }
    format: "go"
  applies_to: ["function", "method"]
  priority: 1
  required: true
  examples:
    - description: "Basic test with testify"
      code: |
        func TestCreateUser(t *testing.T) {
            // Arrange
            assert := assert.New(t)
            require := require.New(t)
            
            // Act
            user, err := CreateUser("John", 25)
            
            // Assert
            require.NoError(err)
            assert.Equal("John", user.Name)
            assert.Equal(25, user.Age)
        }

# Table-driven test pattern
- name: "table_test_pattern"
  category: "testing"
  type: "template"
  description: "Table-driven test pattern for multiple test cases"
  pattern:
    template: |
      func Test{{.Name}}(t *testing.T) {
          tests := []struct {
              name    string
              {{.InputFields}}
              want    {{.OutputType}}
              wantErr error
          }{
              {
                  name: "{{.TestCaseName}}",
                  {{.TestCaseFields}}
              },
          }
          
          for _, tt := range tests {
              t.Run(tt.name, func(t *testing.T) {
                  got, err := {{.FunctionName}}({{.InputParams}})
                  if tt.wantErr != nil {
                      assert.ErrorIs(t, err, tt.wantErr)
                      return
                  }
                  assert.NoError(t, err)
                  assert.Equal(t, tt.want, got)
              })
          }
      }
    format: "go"
  applies_to: ["function", "method"]
  priority: 1
  required: true

# Mock usage pattern
- name: "mock_pattern"
  category: "testing"
  type: "template"
  description: "Standard pattern for using mocks with mockery"
  pattern:
    template: |
      func Test{{.Name}}WithMock(t *testing.T) {
          // Arrange
          mock := mocks.New{{.Interface}}(t)
          mock.On("{{.Method}}", mock.Anything, {{.Params}}).
              Return({{.ReturnValues}})
          
          sut := New{{.Type}}(mock)
          
          // Act
          {{.TestLogic}}
          
          // Assert
          mock.AssertExpectations(t)
      }
    format: "go"
  applies_to: ["interface"]
  priority: 1
  required: true
  examples:
    - description: "Mock usage example"
      code: |
        func TestUserServiceWithMock(t *testing.T) {
            // Arrange
            mockRepo := mocks.NewUserRepository(t)
            mockRepo.On("Get", mock.Anything, "123").
                Return(&User{ID: "123", Name: "John"}, nil)
            
            service := NewUserService(mockRepo)
            
            // Act
            user, err := service.GetUser(context.Background(), "123")
            
            // Assert
            assert.NoError(t, err)
            assert.Equal(t, "John", user.Name)
            mockRepo.AssertExpectations(t)
        }

# Test organization pattern
- name: "test_suite_pattern"
  category: "testing"
  type: "template"
  description: "Pattern for organizing related tests using testify suite"
  pattern:
    template: |
      type {{.Name}}Suite struct {
          suite.Suite
          {{.Fields}}
      }
      
      func (s *{{.Name}}Suite) SetupTest() {
          {{.SetupLogic}}
      }
      
      func (s *{{.Name}}Suite) Test{{.TestName}}() {
          {{.TestLogic}}
      }
      
      func Test{{.Name}}(t *testing.T) {
          suite.Run(t, new({{.Name}}Suite))
      }
    format: "go"
  applies_to: ["struct"]
  priority: 1
  required: true

# Example of a naming rule
- name: "naming_convention"
  category: "style"
  type: "template"
  description: "Naming conventions for Go code"
  pattern:
    template: "{{.Name}}"
    format: "go"
  applies_to: ["interface", "variable", "function", "type"]
  priority: 2
  required: true

# Example of an error handling rule
- name: "error_handling"
  category: "error"
  type: "pattern"
  description: "Standard error handling patterns"
  pattern:
    template: "return fmt.Errorf(\"{{.Operation}}: %w\", err)"
    format: "go"
  applies_to: ["function", "method"]
  priority: 1
  required: true

# Example of a documentation rule
- name: "doc_standard"
  category: "documentation"
  type: "pattern"
  description: "Standard documentation format for Go code"
  pattern:
    template: |
      // {{.Name}} {{.Action}}
      // {{.Description}}
    format: "go"
  applies_to: ["function", "type", "package"]
  priority: 1
  required: true
