rules:
  # Constructor pattern
  - name: "constructor_pattern"
    category: "code"
    description: "Standard constructor pattern for Go types"
    examples:
      - description: "Basic constructor"
        code: |
          func NewUser(name string, age int) *User {
              return &User{
                  name: name,
                  age: age,
              }
          }
      - description: "Constructor with validation"
        code: |
          func NewConfig(serverAddr string, timeout time.Duration) (*Config, error) {
              if serverAddr == "" {
                  return nil, errors.New("server address is required")
              }
              return &Config{
                  serverAddr: serverAddr,
                  timeout:    timeout,
              }, nil
          }
      - description: "Constructor with optional parameters"
        code: |
          type Option func(*Options)

          func NewService(opts ...Option) *Service {
              s := &Service{
                  timeout: 30 * time.Second,
              }
              for _, opt := range opts {
                  opt(s)
              }
              return s
          }

  # Interface naming pattern
  - name: "interface_naming"
    category: "code"
    description: "Go interface naming conventions"
    examples:
      - description: "Single method interface, named after the method name"
        code: |
          type Reader interface {
              Read(p []byte) (n int, err error)
          }
      - description: "Multi-method interface"
        code: |
          type UserService interface {
              Create(ctx context.Context, user *User) error
              Get(ctx context.Context, id string) (*User, error)
              Update(ctx context.Context, user *User) error
              Delete(ctx context.Context, id string) error
          }

  # SOLID Principles
  - name: "single_responsibility_principle"
    category: "code"
    description: "Each type should have one, and only one, reason to change"
    examples:
      - description: "Good: Separate concerns into different types"
        code: |
          type UserService interface {
              CreateUser(ctx context.Context, user *User) error
              GetUser(ctx context.Context, id string) (*User, error)
              UpdateUser(ctx context.Context, user *User) error
              DeleteUser(ctx context.Context, id string) error
          }

          type UserValidator interface {
              ValidateUser(user *User) error
          }

          type UserNotifier interface {
              NotifyUserCreated(ctx context.Context, user *User) error
          }
      - description: "Bad: Mixing different responsibilities"
        code: |
          type UserService interface {
              CreateUser(ctx context.Context, user *User) error
              ValidateUserData(user *User) error
              SendWelcomeEmail(user *User) error
              UpdateUserInCache(user *User) error
          }

  - name: "open_closed_principle"
    category: "code"
    description: "Software entities should be open for extension, but closed for modification"
    examples:
      - description: "Good: Using interfaces and composition for extension"
        code: |
          type PaymentProcessor interface {
              Process(payment *Payment) error
          }

          type StripeProcessor struct {
              client *stripe.Client
          }

          func (s *StripeProcessor) Process(payment *Payment) error {
              // Stripe-specific implementation
              return nil
          }

          type PayPalProcessor struct {
              client *paypal.Client
          }

          func (p *PayPalProcessor) Process(payment *Payment) error {
              // PayPal-specific implementation
              return nil
          }
      - description: "Bad: Using type switches that require modification"
        code: |
          func ProcessPayment(payment *Payment) error {
              switch payment.Type {
              case "stripe":
                  // Stripe-specific code
              case "paypal":
                  // PayPal-specific code
              // Need to modify this function for each new payment type
              default:
                  return errors.New("unsupported payment type")
              }
              return nil
          }

  - name: "liskov_substitution_principle"
    category: "code"
    description: "Subtypes must be substitutable for their base types"
    examples:
      - description: "Good: Maintaining contract in interface implementation"
        code: |
          type Storage interface {
              Save(ctx context.Context, data []byte) error
              Load(ctx context.Context, id string) ([]byte, error)
          }

          type FileStorage struct {
              basePath string
          }

          func (fs *FileStorage) Save(ctx context.Context, data []byte) error {
              // Implements full Storage interface contract
              return nil
          }

          type MemoryStorage struct {
              data map[string][]byte
          }

          func (ms *MemoryStorage) Save(ctx context.Context, data []byte) error {
              // Implements same contract as FileStorage
              return nil
          }

  - name: "interface_segregation_principle"
    category: "code"
    description: "Clients should not be forced to depend on interfaces they do not use"
    examples:
      - description: "Good: Small, focused interfaces"
        code: |
          type Reader interface {
              Read(p []byte) (n int, err error)
          }

          type Writer interface {
              Write(p []byte) (n int, err error)
          }
              
          // Compose interfaces when needed
          type ReadWriter interface {
              Reader
              Writer
          }
      - description: "Bad: Large interface forcing unnecessary implementations"
        code: |
          type FileHandler interface {
              Read(p []byte) (n int, err error)
              Write(p []byte) (n int, err error)
              Close() error
              Seek(offset int64, whence int) (int64, error)
              Truncate(size int64) error
              Sync() error
          }

  - name: "dependency_inversion_principle"
    category: "code"
    description: "High-level modules should not depend on low-level modules. Both should depend on abstractions"
    examples:
      - description: "Good: Depending on interfaces"
        code: |
          type UserRepository interface {
              Save(ctx context.Context, user *User) error
              Find(ctx context.Context, id string) (*User, error)
          }

          type UserService struct {
              repo UserRepository // Depends on abstraction
          }

          func NewUserService(repo UserRepository) *UserService {
              return &UserService{repo: repo}
          }
      - description: "Bad: Depending on concrete implementations"
        code: |
          type PostgresUserRepository struct {
              db *sql.DB
          }

          type UserService struct {
              repo *PostgresUserRepository // Directly depends on concrete type
          }

          func NewUserService(db *sql.DB) *UserService {
              return &UserService{
                  repo: &PostgresUserRepository{db: db},
              }
          }

  # Error handling
  - name: "error_handling"
    category: "code"
    description: "Go error handling patterns"
    examples:
      - description: "Custom error types"
        code: |
          type NotFoundError struct {
              Resource string
              ID      string
          }

          func NewNotFoundError(resource, id string) *NotFoundError {
              return &NotFoundError{
                  Resource: resource,
                  ID:      id,
              }
          }

          func (e *NotFoundError) Error() string {
              return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
          }
      - description: "Error wrapping"
        code: |
          func process(data []byte) error {
              if err := validate(data); err != nil {
                  return fmt.Errorf("validate data: %w", err)
              }
              return nil
          }
      - description: "Error logging, we should not log error if we are returning it"
        code: |
          func process(data []byte) error {
              if err := validate(data); err != nil {
                  slog.Error("failed to validate data", slog.Any("error", err))
                  return nil
              }
              return nil
          }

  # Function documentation
  - name: "func_documentation"
    category: "documentation"
    description: "Standard documentation format for Go functions"
    examples:
      - description: "Simple function documentation"
        code: |
          // Sum adds two integers and returns their sum.
          func Sum(a, b int) int
      - description: "Complex function documentation"
        code: |
          // ProcessData validates and transforms the input data according to the specified options.
          // It applies each transformation sequentially and stops on the first error encountered.
          // Data is the raw input to be processed
          // Options control the transformation behavior
          // Returns processed data in the requested format
          // Returns error if validation fails or any transformation step errors
          func ProcessData(data []byte, opts *Options) ([]byte, error)

  # Package documentation
  - name: "package_documentation"
    category: "documentation"
    description: "Standard documentation format for Go packages"
    examples:
      - description: "Package documentation"
        code: |
          // Package calculator provides basic arithmetic operations
          // and advanced mathematical calculations.
          //
          // It implements common mathematical functions and utilities
          // while ensuring thread-safety and proper error handling.
          package calculator

  # Interface documentation
  - name: "interface_documentation"
    category: "documentation"
    description: "Standard documentation format for Go interfaces"
    examples:
      - description: "Interface documentation"
        code: |
          // Reader is the interface that wraps the basic Read method.
          //
          // Read reads up to len(p) bytes into p. It returns the number of bytes
          // read (0 <= n <= len(p)) and any error encountered.
          type Reader interface {
              Read(p []byte) (n int, err error)
          }

  # Table-driven tests
  - name: "table_tests"
    category: "testing"
    description: "Table-driven test patterns for Go"
    examples:
      - description: "Basic table test"
        code: |
          func TestValidate(t *testing.T) {
              tests := []struct {
                  name    string
                  input   string
                  wantErr bool
              }{
                  {
                      name:    "valid input",
                      input:   "test",
                      wantErr: false,
                  },
                  {
                      name:    "empty input",
                      input:   "",
                      wantErr: true,
                  },
              }

              for _, tt := range tests {
                  t.Run(tt.name, func(t *testing.T) {
                      err := Validate(tt.input)
                      if tt.wantErr {
                          assert.Error(t, err)
                      } else {
                          assert.NoError(t, err)
                      }
                  })
              }
          }
  - name: "mocking"
    category: "testing"
    description: "For mocking we should use mockery tool, which will generate mock for the interface"
    examples:
      - description: "Basic mock"
        code: |
          TestUserService_Create(t *testing.T) {
              ctx := context.Background()
              expected := &User{}

              mockRepo := NewMockUserRepository(t)
              mockRepo.EXPECT().Create(ctx, expected).Return(nil)

              service := NewUserService(mockRepo)
              err := service.Create(context.Background(), &User{})
              assert.NoError(t, err)
          }

  # Application template
  - name: "Excecutable files"
    category: "template"
    description: "All main go files should be logcatead in ./cmd/example-app/main.go directory"
    examples:
      - description: "Main file should not contain any logic, only responsible for starting the application"
        code: |
          package main

          import (
            "context"
            "log/slog"
            "os"
            "os/signal"
            "syscall"

            "github.com/user/example/pkg/cmd"
          )

          // version is the version of the application. It should be set at build time.
          var version = "dev"

          func main() {
            ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

            rootCmd := cmd.InitCommands(version)

            if err := rootCmd.ExecuteContext(ctx); err != nil {
              slog.Error("failed to execute command", slog.Any("error", err))
              os.Exit(1)
            }
          }
  - name: "Command Line Interface"
    category: "template"
    description: "All command line interfaces loggic and also wiring logic should be located in ./pkg/cmd directory"
    examples:
      - description: "CLI commands initialization, we should use cobra framework for designing cli interface of the application. File should be located in ./pkg/cmd/init.go"
        code: |
          package cmd

          import (
            "fmt"
            "log/slog"

            "github.com/spf13/cobra"
          )

          type args struct {
            version              string
            LogLevel             string
            ConfigPath           string
            TextFormat           bool
          }

          // InitCommands initializes and returns the root command for the application.
          func InitCommands(version string) (*cobra.Command, error) {
            args := &args{
              build:   build,
              version: version,
            }

            cmd := &cobra.Command{
              Use:   "example-app",
              Short: "Example application",
              Long:  "Example application for demonstrating best practices",
            }

            cmd.AddCommand(ServerCommand(args))

            cmd.PersistentFlags().StringVar(&args.ConfigPath, "config", "", "config file path")
            cmd.PersistentFlags().StringVar(&args.LogLevel, "loglevel", "info", "log level (debug, info, warn, error)")
            cmd.PersistentFlags().BoolVar(&args.TextFormat, "logtext", false, "log in text format, otherwise JSON")

            return cmd, nil
          }

          // ServerCommand creates a new cobra.Command to start example-app server.
          func ServerCommand(arg *args) *cobra.Command {
            return &cobra.Command{
              Use:   "server",
              Short: "Start Example server",
              Long:  "Start Example server",
              RunE: func(cmd *cobra.Command, _ []string) error {
                if err := initLogger(arg); err != nil {
                  return err
                }

                slog.Info("Starting Example server", slog.String("version", arg.version), slog.String("build", arg.build))

                cfg, err := initConfig(arg)
                if err != nil {
                  return err
                }

                return runServer(cmd.Context(), cfg)
              },
            }
          }
      - description: "Configuration initialization, we should use viper for configuration management. File should be located in ./pkg/cmd/config.go"
        code: |
          package cmd

          import (
            "context"
            "fmt"
            "log/slog"

            "github.com/user/example/pkg/api"
            "github.com/user/example/pkg/repo"
            "github.com/spf13/viper"
          )

          type Config struct {
            Server    api.Config    `mapstructure:"api"`
            Database  repo.Config   `mapstructure:"database"`
          }

          // initConfig initializes the configuration by reading from the specified config file.
          func initConfig(arg *args) (*Config, error) {
            v := viper.New()

            v.SetConfigFile(arg.ConfigPath)

            if err := v.ReadInConfig(); err != nil {
              return nil, fmt.Errorf("failed to read config: %w", err)
            ]

            var cfg Config

            v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
            v.AutomaticEnv()

            if err := v.Unmarshal(&cfg); err != nil {
              return nil, fmt.Errorf("failed to unmarshal config: %w", err)
            }

            slog.Debug("Config loaded", slog.Any("config", cfg))

            return &cfg, nil
          }
      - description: "Logger initialization, we should use log/slog for logging. File should be located in ./pkg/cmd/logger.go"
        code: |
          package cmd

          import (
            "log/slog"
            "os"
          )

          // initLogger initializes the default logger for the application using slog.
          func initLogger(arg *args) error {
            var logLever slog.Level
            if err := logLever.UnmarshalText([]byte(arg.LogLevel)); err != nil {
              return err
            }

            options := &slog.HandlerOptions{
              Level: logLever,
            }

            var logHandler slog.Handler
            if arg.TextFormat {
              logHandler = slog.NewTextHandler(os.Stdout, options)
            } else {
              logHandler = slog.NewJSONHandler(os.Stdout, options)
            }

            logger := slog.New(logHandler).With(
              slog.String("ver", arg.version),
              slog.String("app", "example-app"),
            )

            slog.SetDefault(logger)

            return nil
          }
