rules:
  # Constructor pattern
  - name: "constructor_pattern"
    category: "code"
    description: "Standard constructor pattern for Go types"
    examples:
      - description: "Basic constructor"
        code: |
          func NewUser(name string, age int) *User {
              return &User{
                  name: name,
                  age: age,
              }
          }
      - description: "Constructor with validation"
        code: |
          func NewConfig(serverAddr string, timeout time.Duration) (*Config, error) {
              if serverAddr == "" {
                  return nil, errors.New("server address is required")
              }
              if timeout <= 0 {
                  return nil, errors.New("timeout must be positive")
              }
              return &Config{
                  serverAddr: serverAddr,
                  timeout:    timeout,
              }, nil
          }

  # Interface naming pattern
  - name: "interface_naming"
    category: "code"
    description: "Go interface naming conventions"
    examples:
      - description: "Single method interface"
        code: |
          type Reader interface {
              Read(p []byte) (n int, err error)
          }
      - description: "Multi-method interface"
        code: |
          type UserService interface {
              Create(ctx context.Context, user *User) error
              Get(ctx context.Context, id string) (*User, error)
              Update(ctx context.Context, user *User) error
              Delete(ctx context.Context, id string) error
          }

  # Package organization
  - name: "package_organization"
    category: "code"
    description: "Go package organization patterns"
    examples:
      - description: "Domain-driven package structure"
        code: |
          project/
          ├── cmd/                    # Main applications
          │   └── app/               # Application-specific code
          │       └── main.go        # Application entry point
          ├── pkg/                   # Project packages
          │   ├── api/              # API handlers
          │   ├── core/             # Core business logic
          │   ├── service/          # Business operations
          │   ├── repo/             # Data access
          │   └── types/            # Shared types
      - description: "Package naming"
        code: |
          package user       // Good: single word
          package imageutil  // Good: no underscore for utility
          package api       // Good: short and clear
          package database  // Good: describes functionality

  # Error handling
  - name: "error_handling"
    category: "code"
    description: "Go error handling patterns"
    examples:
      - description: "Custom error types"
        code: |
          type NotFoundError struct {
              Resource string
              ID      string
          }

          func (e *NotFoundError) Error() string {
              return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
          }

          // Usage
          if err := repo.Get(id); err != nil {
              return &NotFoundError{
                  Resource: "user",
                  ID:      id,
              }
          }
      - description: "Error wrapping"
        code: |
          if err := validate(data); err != nil {
              return fmt.Errorf("validate data: %w", err)
          }

  # Function documentation
  - name: "func_documentation"
    category: "documentation"
    description: "Standard documentation format for Go functions"
    examples:
      - description: "Simple function documentation"
        code: |
          // Sum adds two integers and returns their sum.
          func Sum(a, b int) int
      - description: "Complex function documentation"
        code: |
          // ProcessData validates and transforms the input data according to the specified options.
          // It applies each transformation sequentially and stops on the first error encountered.
          // Data is the raw input to be processed
          // Options control the transformation behavior
          // Returns processed data in the requested format
          // Returns error if validation fails or any transformation step errors
          func ProcessData(data []byte, opts *Options) ([]byte, error)

  # Package documentation
  - name: "package_documentation"
    category: "documentation"
    description: "Standard documentation format for Go packages"
    examples:
      - description: "Package documentation"
        code: |
          // Package calculator provides basic arithmetic operations
          // and advanced mathematical calculations.
          //
          // It implements common mathematical functions and utilities
          // while ensuring thread-safety and proper error handling.
          package calculator

  # Interface documentation
  - name: "interface_documentation"
    category: "documentation"
    description: "Standard documentation format for Go interfaces"
    examples:
      - description: "Interface documentation"
        code: |
          // Reader is the interface that wraps the basic Read method.
          //
          // Read reads up to len(p) bytes into p. It returns the number of bytes
          // read (0 <= n <= len(p)) and any error encountered.
          type Reader interface {
              Read(p []byte) (n int, err error)
          }

  # Table-driven tests
  - name: "table_tests"
    category: "testing"
    description: "Table-driven test patterns for Go"
    examples:
      - description: "Basic table test"
        code: |
          func TestValidate(t *testing.T) {
              tests := []struct {
                  name    string
                  input   string
                  wantErr bool
              }{
                  {
                      name:    "valid input",
                      input:   "test",
                      wantErr: false,
                  },
                  {
                      name:    "empty input",
                      input:   "",
                      wantErr: true,
                  },
              }

              for _, tt := range tests {
                  t.Run(tt.name, func(t *testing.T) {
                      err := Validate(tt.input)
                      if (err != nil) != tt.wantErr {
                          t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
                      }
                  })
              }
          }

  # Test setup/teardown
  - name: "test_setup"
    category: "testing"
    description: "Test setup and teardown patterns"
    examples:
      - description: "Setup and teardown"
        code: |
          func TestService(t *testing.T) {
              // Setup
              s := NewService()
              defer s.Close() // Teardown

              t.Run("Create", func(t *testing.T) {
                  // Test create operation
              })

              t.Run("Update", func(t *testing.T) {
                  // Test update operation
              })
          }
